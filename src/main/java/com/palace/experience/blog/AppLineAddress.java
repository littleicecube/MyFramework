package com.palace.experience.blog;

public class AppLineAddress {
/**
 * 
intel 段式内存管理模式(非保护模式)
逻辑地址 ----(段式转换)------> 线性地址也是物理地址

intel 段页式内存管理模式(保护模式)
逻辑地址 ----(段式转换)------> 线性地址-----(分页转换)----->物理地址

假设存在一个32位的物理地址空间,可供寻址的空间大小0到4GB
|------------------ 2^32 = 4*2^10*2^10 = 4GB ------------------|
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 19   0XFFFFFFFF 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...... |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+


假设存在应用程序A编译后生成一个可以在操作系统上运行的文件,文件中段描述符的段基址是5,段界限长度为6
假设存在应用程序B编译后生成一个可以在操作系统上运行的文件,文件中段描述符的段基址是11,段界限长度为6

|-操作系统的地址空间-|----线程A地址空间----|----线程B地址空间----|
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 19   0XFFFFFFFF 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...... |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
当操作系统启动后会独占一段物理内存作为一个进程存在,操作系统用来管理物理内存,文件系统,非操作系统进程的调度以及和硬件交互等
当应用程序A被启动时,操作系统分配地址空间5-10的物理地址空间给应用程序A使用
当应用程序B被启动时,操作系统分配地址空间11-16的物理地址空间给应用程序B使用
那么应用程序A和应用程序B就可以相互不影响的独立运行

上面的描述中程序A和程序B中的段描述符的基地址不一样才能被操作系统加载到同一块内存上而相互不影响,而在linux系统中每个
程序的段基址都是0,那么程序A的段基址是0,程序B的段基址也是0,段描述符中的段基地址都是一样的,那么在通过上面的方式加载程序A和B,
后加的代码就会把前面的给覆盖掉,我们知道linux中是可以存在多个进程相互不干扰的运行的,且他们的段基址都是0,之所以可以并行的运行
是因为他么运行在intel的保护模式下即段页式内存管理模式下
基本模型如:
操作系统还是独占一段物理内存,不能给其他应用程序的进程共享,而其他的应用程序进程可以指向相同的地址空间
			   |-----线程A地址空间---|
|-操作系统的地址空间-|-----线程B地址空间---|
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 19   0XFFFFFFFF 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+--+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...... |  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+--+
	
分页机制在32位下
线性地址需要经过分页机制转换成物理地址

存在一个映射结构如下:
总目录PGD(Page Global Directory)
中间目录PMD(Page Middle Derectory)
页表PT(Page Table)
|---------PGD-------|-------PMD---------|-------PT----------|
+-------------------+-------------------+-------------------+
|    目录   	   	 	|      	页     	 		|   	偏移地址    	  	|
+-------------------+-------------------+-------------------+


				|---10---|--10-----|----12-----|
地址addrA = 		00000000050000000003000000000001

应用程序A的根据自己的映射目录信息映射的过程
	高10位:0000000005
+-------------------+
|    目录   	   	| 8	|
+-----------------|-+
				  |		    中间10位:0000000003
				  |		+-------------------+
				  |---->|      	页     	 	| 7	|
						+-----------------|-+
										  |		       低12位:000000000001
										  |		+-------------------+
										  |---->|   	偏移地址    	  	|
										  		+-------------------+
										  
00000000050000000003000000000001
映射后的物理地址为:
00000000080000000007000000000001									  
										  
##########################################################################	
	
				|---10---|--10-----|----12-----|
地址addrB = 		00000000050000000003000000000001								  
应用程序B的根据自己的映射目录信息映射的过程
	高10位:0000000005
+-------------------+
|    目录   	   	| 6	|
+-----------------|-+
				  |		    中间10位:0000000003
				  |		+-------------------+
				  |---->|      	页     	 	| 2	|
						+-----------------|-+
										  |		       低12位:000000000001
										  |		+-------------------+
										  |---->|   	偏移地址    	  	|
										  		+-------------------+
										  
00000000050000000003000000000001 映射后的物理地址为=>00000000060000000002000000000001


以上实例应用程A和应用程序B的线性地址都是00000000050000000003000000000001,在经过该应用程序A的映射目录转换
后得到的实际物理地址和应用程序B的到的实际物理地址不同,因此保证了应用程序可以并行的运行.
综上可知:
在linux32位程序中,在段页式内存管理模式即保护模式下,虽然不同应用程序的段基址都是相同,且相同的地址下得到的线性地址也是相同的
但是经过映射地址转换到不同的物理地址后是可以相互不影响的并行运行的,也可以按需要分配节省内存

32位下运行过程:
1)操作系统启动后检查硬件中的物理内存的大小,假设有8GB内存,然后把这8GB内存按照一页4KB的大小进行分组,那么共有8GB/4KB=2M个页面
2)启动应用程序A,创建应用程序A的分页映射表
3)启动应用程序B,创建应用程序B的分页映射表
4)开始获取应用程序A线性地址00000000050000000003000000000001对应的物理地址
	4.1)获取2中创建的分页映射表
	4.2)获取线性地址的高10位:0000000005从分页映射表PGD中查询对应的映射关系,发现没有对应的映射关系抛出一个缺页异常,操作系统捕捉后
	从1中初始化的2M个物理内存页面中获取一个空闲的页面作为8对应的PMD并关联到PGD中
	4.3)获取线性地址的中间10位:0000000003从分页映射表PMD中查询对应的映射关系,发现没有对应的映射关系抛出一个缺页异常,操作系统捕捉后
	从1中初始化的2M个物理内存页面中获取一个空闲的页面作为7对应的PT并关联到PMD中
	4.4)获取线性地址的低12位,作为PT的偏移地址,最终得到线性地址的物理地址
	 
 */
}
