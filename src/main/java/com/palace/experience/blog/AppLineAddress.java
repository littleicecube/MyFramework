package com.palace.experience.blog;

public class AppLineAddress {
/**
 * 
应用程序编译后的代码是一个逻辑地址空间
在intel cpu中有段式内存管理和段页式内存管理

//代码段假设其段基址为:0000000xx
SEGMENT_CODE:
				+----------+----------------------------------------+
				|000000040 |mov	gs, ax                              |
				+----------+----------------------------------------+
				|000000041 |mov	edi, (80 * 13 + 0) * 2              |
				+----------+----------------------------------------+
				|000000042 |mov	ah, 0Ch                             |
				+----------+----------------------------------------+
				|000000043 |mov	al, 'L'                             |
				+----------+----------------------------------------+
				|000000044 |mov	[gs:edi], ax                        |
				+----------+----------------------------------------+
				|	...... |    ......							    |
				+----------+----------------------------------------+
代码段的段描述符:

|	第7字节	  	|	第6字节		|	第5字节	  	|	第4字节		|	第3字节	  	|	第2字节		|	第1字节	  	|	第0字节		|	
|-段基址(31..24)--|属性内容值|	段界限2(19..16)位		|-----段基址(23..0)位	----------------------------|-------段界限(15..0)(位)----------|
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|	0000	  	| 属性内容	|	0000	|	属性内容	|					0000000xx					|				5				|
|---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+				
				
在执行000000040这行代码时
1)首先会通过一个 段选择子在段描述符表中定位到代码段的段描述符,然后读取段基址信息0000000xx存放到代码寄存器(ss)中
2)通过代码段段基址+段内偏移得到一个地址称为线性地址即0000000xx:000000040
3)将得到的线性地址发送到数据总线上获取对应地址的值存放到寄存器中
在段式内存管理模式下线性地址空间就是物理地址空间,所以得到线性地址后直接发送到地址总线就可以获取到对应地址的内容



假设存在一个32位的物理地址空间,可供寻址的空间大小0到4GB
|------------------ 2^32 = 4*2^10*2^10 = 4GB ------------------|
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 19   0XFFFFFFFF 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...... |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+


假设存在应用程序A编译后生成一个可以在操作系统上运行的文件,文件中段描述符的段基址是5,段界限长度为6
假设存在应用程序B编译后生成一个可以在操作系统上运行的文件,文件中段描述符的段基址是11,段界限长度为6

|-操作系统的地址空间-|----线程A地址空间----|----线程B地址空间----|
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 19   0XFFFFFFFF 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...... |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+
当操作系统启动代码被加载到内存,操作系统本身也是一个应用进程
操作系统启动后获取当前物理内存的总大小有4GB,然后本身占用0-4的内存地址空间
当应用程序A被启动时,操作系统分配地址空间5-10的物理地址空间给应用程序A使用
当应用程序B被启动时,操作系统分配地址空间11-16的物理地址空间给应用程序B使用
那么应用程序A和应用程序B就可以相互不影响的独立运行




上面的描述中程序A和程序B中的段描述符的基地址空间都不一样才能不操作系统加载到同一块内存上而相互不影响
当今程序代码在经过编译和连接后生成的代码在32位情况下都有4GB的逻辑地址空间且应用程序A和应用程序B的
段描述符中的段基地址都是一样的,那么在通过上面的方式加载程序A和B,后加的代码就会把前面的给覆盖掉
从现有事实看虽然微信和qq的段基地址相同但是还是能在一台机器上同时运行并且相互隔离没有出现覆盖的情况
从已有的资料可知intel中还有一个段页式内存管理模式

假设程序A段基地址为0000100,段长度为6
假设程序B段基地址为0000100,段长度为6
操作系统的空间是独立的不被其他应用程序共享的,程序A和程序B的加载情况如下
在段式内存管理模式下线性地址空间就是物理地址空间,那么程序B就会覆盖程序A,在开启段页式内存管理模式后线性
地址就不在是物理地址还需要在转换一次才能得到真正的物理地址

			   |-----线程A地址空间---|
|-操作系统的地址空间-|-----线程B地址空间---|
0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 19   0XFFFFFFFF 
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+--+
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | ...... |  |
+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--------+--+
	
逻辑地址--->线性地址
在实模式下也就是段式内存管理模式下线性地址就是物理地址

逻辑地址--->线性地址--->逻辑地址
在保护模式下也就是段页式内存管理模式下线性地址需要进一步转换才能得到物理地址
	
	
	
	
	 
 */
}
