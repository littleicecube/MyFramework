package com.palace.experience;

import com.palace.experience.CreateTable.Column;

public class Address {
 /**
  * 
1)逻辑地址[虚拟地址];2)线性地址;3)物理地址

//数据段
SEGMENT_DATA:
				+----------+----------------------------------------+
				|000000001 |SPValueInRealMode	dw	0               |
				+----------+----------------------------------------+
				|000000002 |PMMessage:			db	"错误数据"      |
				+----------+----------------------------------------+
				|000000003 |OffsetPMMessage		equ	PMMessage - $$  |
				+----------+----------------------------------------+
				|000000004 |DataLen			equ	$ - SEGMENT_DATA    |
				+----------+----------------------------------------+
//堆栈端
SEGMENT_STACK:
				+----------+----------------------------------------+
				|000000006 |times 512 db 0                          |
				+----------+----------------------------------------+
				|000000008 |  ......                                |
				+----------+----------------------------------------+
				|000000008 |  ......                                |
				+----------+----------------------------------------+
				|000000008 |  ......                                |
				+----------+----------------------------------------+
				|000000008 |  ......                                |
				+----------+----------------------------------------+
				|000000007 |TopOfStack	equ	$ - SEGMENT_STACK-1     |
				+----------+----------------------------------------+
//代码段
SEGMENT_CODE:
				+----------+----------------------------------------+
				|000000009 |mov	ax, SelectorVideo                   |
				+----------+----------------------------------------+
				|000000010 |mov	gs, ax                              |
				+----------+----------------------------------------+
				|000000011 |mov	edi, (80 * 13 + 0) * 2              |
				+----------+----------------------------------------+
				|000000012 |mov	ah, 0Ch                             |
				+----------+----------------------------------------+
				|000000013 |mov	al, 'L'                             |
				+----------+----------------------------------------+
				|000000014 |mov	[gs:edi], ax                        |
				+----------+----------------------------------------+
				|000000015 |jmp	SelectorCode16:0                    |
				+----------+----------------------------------------+
				|000000016 |CodeALen	equ	$ - SEGMENT_CODE        |
				+----------+----------------------------------------+
//程序入口
SEGMENT_BEGIN:
				+----------+----------------------------------------+
				|000000018 |mov	ax, cs                              |
				+----------+----------------------------------------+
				|000000019 |movzx	eax, ax                         |
				+----------+----------------------------------------+
				|000000020 |shl	eax, 4                              |
				+----------+----------------------------------------+
				|000000021 |add	eax, LABEL_SEG_CODE16               |
				+----------+----------------------------------------+
				|000000022 |mov	word [LABEL_DESC_CODE16 + 2], ax    |
				+----------+----------------------------------------+
				|000000023 |shr	eax, 16                             |
				+----------+----------------------------------------+
				|000000024 |mov	byte [LABEL_DESC_CODE16 + 4], al    |
				+----------+----------------------------------------+
				|000000025 |mov	byte [LABEL_DESC_CODE16 + 7], ah    |
				+----------+----------------------------------------+
				|	...... |    ......							    |
				+----------+----------------------------------------+

以下假设都是在32位平台上

假设存在一个java格式的代码,假设在32位平台上编译完成后的汇编代码如上为应用程序A,每一行代码都有自己在进程上下文中的地址编号
当应用程序A被操作系统加载到内存后,从应用程序的入口SEGMENT_BEGIN开始执行代码,执行完每一行代码后,cpu会根据下一个指令
的地址从内存中获取对应的值,如此往复应用程序A会在cpu的循环中不断被执行.
其中上面编译完的汇编代码的地址就是程序的逻辑地址也叫虚拟地址,整个程序A的上文是应用程序A的逻辑地址空间也是虚拟地址空间





逻辑地址->线性地址
	从逻辑地址到线性地址:从上可知逻辑地址程序被编译后编译器按照一定的逻辑规则为代码段,数据段,堆栈段设置的地址.且在32位的
平台上应用程序A被编译完成后拥有对大4G的逻辑地址空间.也就是代码中最大能访问到的地址为0XFFFFFFFF处存储的数据
	假设当前有一台机器安装有4G物理内存,一个逻辑地址空间是4G的应用程序被加载后假设把4G的物理内存给占用完了,那么一台4G的机器就只能
在同一个时间段只能运行一个应用程序,但是从现在的windows和linux操作系统上看,一台装有4G物理地址的机器能运行成百上千的应用程序,这又是怎么做到的.
	从编译出的应用程序的逻辑地址空间可以看出,一个应用程序的逻辑地址空间虽然有4G的地址空间可供寻址,但是一般情况下一个应用程序也不会用完4G的逻辑地址空间,也就是
4G的逻辑地址空间是理论上可以被一个应用程序分配和使用的,但是不一定要使用完,那么操作系统在加载应用程序时如果能合理运用物理空间,将不同的应用程序的逻辑地址映射
到物理内存的不同区域,就可以实现一台4G物理内存的机器,可以在同一时间段运行多个应用程序.
既然存在从逻辑地址到物理地址的映射关系,那么肯定需要一个结构作为桥梁来描述之间的转换,在x86中存在一个段结构描述信息用来限定1.逻辑地址映射到物理内存的哪个地址作为
起始地址2.从起始地址开始多长的内存是属于当前应用程序的物理空间3.这些地址空间的对应的额外属性信息
段信息描述表:共8字节64位,其中有段基址信息,段界限信息,段属性信息
1)段基址占用段描述表的第2字节,第3字节,第4字节第7字节,长度共32位.用来描述物理内存中从哪个地址开始作物应用程序的开始地址
2)段界限占用段描述表的第0字节,第1字节和第6字节的低4位,长度共20位.用来描述从段基址开始多长的物理内存段属于当前应用程序
3)段属性占用段描述表的第5字节和第6字节的高4位,长度共12位,应用程序占用的物理内存地址的属性信息
|	第7字节	  	|	第6字节		|	第5字节	  	|	第4字节		|	第3字节	  	|	第2字节		|	第1字节	  	|	第0字节		|	
+---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+
|段基址(31..24)位	|		属性和段界限2(19..16)位		|					段基址(23..0)位				|		段界限(15..0)(位)			|
|	基地址2	  	| 属性内容	|	段界限2	|	属性内容	|						基址1						|			段界限1				|
|---------------+---------------+---------------+---------------+---------------+---------------+---------------+---------------+

	假设现在有一台机器安装有4G物理内存,现在有三个应用程序A,B,C.这三个应用程序每个都拥有4G的逻辑地址空间,但是现在三个程序都只是使用了自己4G逻辑地址空间的1G空间.在操作系统启动的时候,
操作系统会在自己的进程中维护一个段描述信息的数组,当一个应用程序启动后,操作系统会根据当前机器的物理内存使用情况,为启动的应用程序分配一个段描述信息,并设置当前应用程序被映射到物理内存的起始地址和地址长度
当三个程序都被启动后,物理内存中就由四部分组成  操作系统1G,应用程序A1G,应用程序B1G,应用程序C1G.在x86的cpu中有一个64位的寄存器,如果当前cpu切换到应用程序A运行,那么应用程序A的段描述信息就
会被加载到对应的寄存其中,cpu就会把应用程序中逻辑地址空间中的信息按照段描述信息加载到物理内存中,对应的地址,然后跳转到应用程序的入口开始执行
此时应用程序的逻辑地址经过一系列转换变成的线性地址空间,而此时的线性地址是真实的物理地址,这样运行后就会避免后面加载的应用程序把前面加载到物理内存的数据给覆盖掉.三个程序的逻辑地址空间中的内容分别被加载
到不同的物理地址空间中运行,相互不干扰

线性地址->物理地址

 */
	public static void createRow(StringBuilder colLine,StringBuilder colVal,Column col) {
		colLine.append("+");
		colVal.append("|");
		for(int i=0;i<col.getColumnLen();i++) {
			colLine.append("-");
		}
		int len = col.getColumnLen();
		int valLen = col.getColumnVal().length();
		
		colVal.append(col.getColumnVal());
		for(int i =0;i<len-valLen;i++) {
			colVal.append(" ");
		}
	}

}






